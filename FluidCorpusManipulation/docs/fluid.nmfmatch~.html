<!--
Part of the Fluid Corpus Manipulation Project (http://www.flucoma.org/)
Copyright 2017-2019 University of Huddersfield.
Licensed under the BSD-3 License.
See license.md file in the project root for full license information.
This project has received funding from the European Research Council (ERC)
under the European Union’s Horizon 2020 research and innovation programme
(grant agreement No 725899).
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="./_c74_common.css">
<title>fluid.nmfmatch~ Reference</title>
<style>
	* {
		font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
		--blue: rgb(80,164,252);
		--dark-blue: #204265;
	}

	body {
		padding: 1em;
	}

	h1 {
		text-decoration: underline;
		background-color: var(--blue);
		color: white;
		padding: 0.25em;
		margin: 0;
	}
	h2 {
		border-bottom: 0.5px solid rgba(128, 128, 128, 0.513);
	}

	a {
		color: var(--blue);
	}

	a:hover {
		background-color: var(--blue);
		color: white;
	}
	
	.type, .defaultval { 
		font-weight: normal; 
  }
</style> 
</head>
<body>
  <h1 class="ref_title">fluid.nmfmatch~</h1>
  <div class="digest">Realtime Non-Negative Matrix Factorisation with Fixed Bases</div>
  <section class="object_description">
    <h2>Description</h2> 
    
    <p>Matches an incoming audio signal against a set of spectral templates</p>

    
  </section> 
  <section class="object_discussion"> 
    <h2>Discussion</h2> 
    
    <p>This uses a slimmed-down version of Nonnegative Matrix Factorisation (NMF, Lee, Daniel D., and H. Sebastian Seung. 1999. ‘Learning the Parts of Objects by Non-Negative Matrix Factorization’. Nature 401 (6755): 788–91. <a class="reference external" href="https://doi.org/10.1038/44565">https://doi.org/10.1038/44565</a>.)</p>
<p>It outputs at kr the degree of detected match for each template (the activation amount, in NMF-terms). The spectral templates are presumed to have been produced by the offline NMF process (BufNMF), and must be the correct size with respect to the FFT settings being used (FFT size / 2 + 1 frames long). The components of the decomposition are determined by the number of channels in the supplied buffer of templates, up to a maximum set by the maxComponents parameter.</p>
<p>NMF has been a popular technique in signal processing research for things like source separation and transcription (see e.g Smaragdis and Brown, Non-Negative Matrix Factorization for Polyphonic Music Transcription.), although its creative potential is so far relatively unexplored. It works iteratively, by trying to find a combination of amplitudes ('activations') that yield the original magnitude spectrogram of the audio input when added together. By and large, there is no unique answer to this question (i.e. there are different ways of accounting for an evolving spectrum in terms of some set of templates and envelopes). In its basic form, NMF is a form of unsupervised learning: it starts with some random data and then converges towards something that minimizes the distance between its generated data and the original:it tends to converge very quickly at first and then level out. Fewer iterations mean less processing, but also less predictable results.</p>
<p>The whole process can be related to a channel vocoder where, instead of fixed bandpass filters, we get more complex filter shapes and the activations correspond to channel envelopes.</p>


    <p>Read more about fluid.nmfmatch~ on the <a href='https://learn.flucoma.org/reference/nmfmatch'>learn platform</a>.</p>
    
    <p>fluid.nmfmatch~ is part of the Fluid Decomposition Toolkit of the FluCoMa project. For more explanations, learning material, and discussions on its musicianly uses, visit <a href="http://www.flucoma.org/">flucoma.org</a>.</p>
  </section>
  <section class="argument_section">
    <h2>Arguments</h2><h3 class="argument_name">Maximum Number of Components<span class="type"> [number]</span></h3> 
      <div class="optional">Optional</div><span class="defaultval"> (default: 20)</span><div class="description"><p>Shorthand argument for <code>maxcomponents</code></p>
</div>
      <!--  --></section> 
  <section class="attribute_section">
    <h2>Attributes</h2><div class="attribute_group">
      <h3 class="attribute_name">bases
        <span class="type"> [symbol]</span>
        <span class="defaultval"> (default: None)</span>
      </h3>
      <div class="description"><p>The buffer containing the different bases that the input signal will be matched against. Bases must be (fft size / 2) + 1 frames. If the buffer has more than maxComponents channels, the excess will be ignored.</p>
</div><!--  -->
    </div><div class="attribute_group">
      <h3 class="attribute_name">fftsettings
        <span class="type"> [int]</span>
        <span class="defaultval"> (default: [[&#39;winSize&#39;, 1024], [&#39;hopSize&#39;, -1], [&#39;fftSize&#39;, -1]])</span>
      </h3>
      <div class="description"><p>FFT settings consist of three numbers representing the window size, hop size and FFT size in samples:</p>
<p>The hop size and fft size can both be set to -1 (and are by default), with slightly different meanings:</p>
<ul class="simple">
<li>For the hop size, -1 = <code>windowsize/2</code></li>
<li>For the FFT size, -1 = <code>windowsize</code> snapped to the nearest equal / greater power of 2 (e.g. <code>windowsize 1024</code> =&gt; <code>fftsize 1024</code>, but <code>windowssize 1000</code> also =&gt; <code>fftsize 1024</code>)</li>
</ul>
<p><strong>Constraints</strong></p>
<ul class="simple">
<li>FFTSize, if != -1, will snap to the next greatest power of two &amp;gt; 4</li>
<li>The maximum FFT size is limited to the value of the <code>maxfftsize</code> argument</li>
<li>if FFT size != -1, then window size is clipped at FFT size</li>
</ul>
</div><!--  -->
    </div><div class="attribute_group">
      <h3 class="attribute_name">iterations
        <span class="type"> [number]</span>
        <span class="defaultval"> (default: 10)</span>
      </h3>
      <div class="description"><p>The NMF process is iterative, trying to converge to the smallest error in its factorisation. The number of iterations will decide how many times it tries to adjust its estimates. Higher numbers here will be more CPU intensive, lower numbers will be more unpredictable in quality.</p>
<p><strong>Constraints</strong></p>
<ul class="simple">
<li>Minimum: <code>1</code></li>
</ul>
</div><!--  -->
    </div><div class="attribute_group">
      <h3 class="attribute_name">maxcomponents
        <span class="type"> [number]</span>
        <span class="defaultval"> (default: 20)</span>
      </h3>
      <div class="description"><p>The maximum number of elements the NMF algorithm will try to divide the spectrogram of the source in. This dictates the number of output channels. This cannot be modulated.</p>
<p><strong>Constraints</strong></p>
<ul class="simple">
<li>Minimum: <code>1</code></li>
<li>Maximum: <code>maxmaxcomponents</code></li>
</ul>
</div><!--  -->
    </div><div class="attribute_group">
      <h3 class="attribute_name">maxfftsize
        <span class="type"> [number]</span>
        <span class="defaultval"> (default: -1)</span>
      </h3>
      <div class="description"><p>Set an explicit upper bound on the FFT size at object instantiation. The default of -1 sets this to whatever the initial FFT size is</p>
</div><!--  -->
    </div><div class="attribute_group">
      <h3 class="attribute_name">maxmaxcomponents
        <span class="type"> [number]</span>
        <span class="defaultval"> (default: -1)</span>
      </h3>
      <div class="description"><p>Manually sets a maximum value for <code>maxcomponents</code>. Can only be set at object instantiation. The default of -1 sets this equal to the initial value of <code>maxcomponents</code></p>
</div><!--  -->
    </div><div class="attribute_group">
      <h3 class="attribute_name">warnings
        <span class="type"> [number]</span>
        <span class="defaultval"> (default: 0)</span>
      </h3>
      <div class="description"><p>Enable warnings to be issued whenever a parameter value is constrained (e.g. clipped)</p>
</div><!--  -->
    </div></section> 
  <section class="method_section"> 
    <h2>Messages</h2><div class="method_group">
      <h3 class="method_name" name="reset">reset</h3>
      <div class="description"> Calling <span class="messagename" data-message="reset"> reset </span> will change parameter values back to those the object was <em> created </em> with, i.e. any attribute values set in the box will be retained </div>
    </div>
  </section> 
  <section class="seealso"> 
    <h2>See Also</h2><h3 class="seealso_name"><a href="fluid.nmffilter~.html">NMFFilter</a></h3><h3 class="seealso_name"><a href="fluid.bufnmf.html">BufNMF</a></h3></section> 
</body>
</html>